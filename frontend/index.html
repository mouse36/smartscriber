<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Transcription Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .title {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 1rem;
            margin-bottom: 40px;
            line-height: 1.4;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .upload-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 15px 30px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .upload-button:hover {
            background: #0056b3;
        }

        .upload-icon {
            width: 20px;
            height: 20px;
        }

        .file-input {
            display: none;
        }

        .files-container {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 120px;
            display: none;
        }

        .files-container.has-files {
            display: block;
        }

        .file-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .file-preview {
            width: 60px;
            height: 60px;
            background: #6c757d;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: relative;
        }

        .file-size {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #007bff;
            color: white;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 10px;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .file-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .audio-icon {
            width: 30px;
            height: 30px;
            fill: white;
        }

        .file-info {
            flex-grow: 1;
        }

        .file-name {
            font-weight: 500;
            color: #333;
            margin-bottom: 5px;
        }

        .file-status {
            font-size: 0.9rem;
            color: #666;
        }

        .error-message {
            color: #dc3545;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #28a745;
            border-radius: 3px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .remove-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-button:hover {
            background: #c82333;
        }

        .download-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            display: none;
        }

        .download-button:hover {
            background: #218838;
        }

        .download-button.show {
            display: block;
        }

        .transcribe-button {
            display: block;
            width: 200px;
            margin: 0 auto 30px;
            padding: 15px 30px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .transcribe-button:hover {
            background: #218838;
        }

        .transcribe-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .transcript-container {
            display: none;
            margin-top: 30px;
        }

        .transcript-container.show {
            display: block;
        }

        .transcript-item {
            margin-bottom: 25px;
        }

        .transcript-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .transcript-field {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            resize: vertical;
            background: #fafafa;
        }

        .transcript-field.error-field {
            border-color: #dc3545;
            background-color: #fff3f3;
            color: #721c24;
        }

        .success-section {
            text-align: center;
            padding: 20px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .success-section.show {
            display: block;
        }

        .checkmark {
            width: 50px;
            height: 50px;
            background: #28a745;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 15px;
        }

        .checkmark-icon {
            width: 24px;
            height: 24px;
            fill: white;
        }

        .success-text {
            color: #155724;
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 15px;
        }

        .error-summary {
            color: #dc3545;
            font-size: 0.95rem;
            margin-bottom: 15px;
            text-align: left;
            max-width: 100%;
            word-wrap: break-word;
        }

        .backend-error {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #dc3545;
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: 500;
            z-index: 1000;
            display: none;
        }

        .backend-error.show {
            display: block;
        }

        .testing-mode-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            text-align: center;
            font-weight: 500;
            z-index: 999;
            display: none;
        }

        .testing-mode-banner.show {
            display: block;
        }

        .testing-mode-banner.testing {
            background: #28a745;
            color: white;
        }

        .testing-mode-banner.production {
            background: #ffc107;
            color: black;
        }

        .download-all-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 25px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .download-all-button:hover {
            background: #0056b3;
        }

        .quality-control-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 25px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-left: 10px;
        }

        .quality-control-button:hover {
            background: #1e7e34;
        }

        .quality-control-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .download-icon {
            width: 18px;
            height: 18px;
        }

        .qc-icon {
            width: 18px;
            height: 18px;
        }

        .quality-control-section {
            margin-top: 40px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
        }

        .section-title {
            font-size: 1.8rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            text-align: center;
        }

        .section-subtitle {
            text-align: center;
            color: #666;
            font-size: 1rem;
            margin-bottom: 30px;
            transition: color 0.3s ease;
        }

        .revise-files-container {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 120px;
            transition: border-color 0.3s ease;
        }

        .revise-files-container.has-files {
            border-color: #28a745;
            background: #f8fff9;
        }

        .revise-file-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            position: relative;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
        }

        .revise-file-item:hover {
            border-color: #28a745;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.1);
        }

        .revise-file-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .revise-file-info {
            flex: 1;
        }

        .revise-file-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .revise-file-size {
            color: #666;
            font-size: 0.9rem;
        }

        .revise-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 15px 30px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 auto;
            display: block;
        }

        .revise-button:hover:not(:disabled) {
            background: #1e7e34;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .revise-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .revise-icon {
            width: 20px;
            height: 20px;
        }

        .revise-progress-container {
            margin-top: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
        }

        .revise-results-container {
            margin-top: 30px;
        }

        .revise-result-item {
            margin-bottom: 25px;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .revise-result-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .revise-result-title::before {
            content: "✅";
            font-size: 1.2rem;
        }

        .revise-result-field {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.6;
            resize: vertical;
            background: #fafafa;
            transition: border-color 0.3s ease;
        }

        .revise-result-field:focus {
            outline: none;
            border-color: #28a745;
            box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.1);
        }

        .revision-complete-section {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 1px solid #c3e6cb;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.1);
        }

        .download-all-revised-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 25px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .download-all-revised-button:hover:not(:disabled) {
            background: #0056b3;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }

        .download-all-revised-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .quality-control-status {
            text-align: center;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-weight: 500;
        }

        .quality-control-status.ready {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .quality-control-status.completed {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .quality-control-status.waiting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
    </style>
</head>
<body>
    <div class="backend-error" id="backendError">
        ⚠️ Backend server is not running. Please start the backend server to use this application.
    </div>
    
    <div class="testing-mode-banner" id="testingModeBanner">
        🧪 Testing Mode: Whisper API is disabled for free development testing
    </div>
    
    <div class="container">
        <h1 class="title">Audio Transcription Tool</h1>
        <p class="subtitle">Accepted file types: .mp3, .wav, .m4a, .flac, .ogg, .mp4, .mpeg, .mpga, .webm, .m4v, .wma, .aac, .m4b, .m4p, .m4r, .srt</p>
        
        <div class="upload-section">
            <button class="upload-button" onclick="document.getElementById('fileInput').click()">
                <svg class="upload-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                    <path d="M12,11L16,15H13V19H11V15H8L12,11Z" />
                </svg>
                Choose Files
            </button>
            <input type="file" id="fileInput" class="file-input" multiple 
                   accept=".mp3,.wav,.m4a,.flac,.ogg,.mp4,.mpeg,.mpga,.webm,.m4v,.wma,.aac,.m4b,.m4p,.m4r,.srt">
        </div>

        <div class="files-container" id="filesContainer">
            <!-- Files will be dynamically added here -->
        </div>

        <button class="transcribe-button" id="transcribeButton" onclick="startTranscription()" disabled>
            Transcribe
        </button>

        <div class="transcript-container" id="transcriptContainer">
            <!-- Individual transcript fields will be dynamically added here -->
        </div>

        <div class="success-section" id="successSection">
            <div class="checkmark">
                <svg class="checkmark-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z" />
                </svg>
            </div>
            <div class="success-text">Transcription Complete!</div>
            <div class="error-summary" id="errorSummary"></div>
            <button class="download-all-button" onclick="downloadAllTranscripts()">
                <svg class="download-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
                </svg>
                Download All Transcripts
            </button>
        </div>

        <!-- Quality Control Section -->
        <div class="quality-control-section" id="qualityControlSection" style="display: none;">
            <h2 class="section-title">Quality Control</h2>
            <p class="section-subtitle" id="qualityControlSubtitle">Waiting for all transcriptions to complete...</p>
            
            <div class="quality-control-status" id="qualityControlStatus" style="display: none;">
                <!-- Status will be dynamically updated -->
            </div>
            
            <div class="revise-files-container" id="reviseFilesContainer">
                <!-- Files ready for revision will be added here -->
            </div>

            <button class="revise-button" id="reviseButton" onclick="startQualityControl()" disabled>
                <svg class="revise-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z" />
                </svg>
                Revise Transcripts
            </button>

            <div class="revise-progress-container" id="reviseProgressContainer" style="display: none;">
                <!-- Progress bars will be added here -->
            </div>

            <div class="revise-results-container" id="reviseResultsContainer" style="display: none;">
                <!-- Revised transcript previews will be added here -->
            </div>

            <div class="revision-complete-section" id="revisionCompleteSection" style="display: none;">
                <div class="checkmark">
                    <svg class="checkmark-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z" />
                    </svg>
                </div>
                <div class="success-text">Revision Complete!</div>
                <button class="download-all-revised-button" onclick="downloadAllRevisedTranscripts()">
                    <svg class="download-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
                    </svg>
                    Download All Revised Transcripts
                </button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'http://localhost:5000';
        let selectedFiles = [];
        let transcriptionResults = {};
        let progressInterval = null;
        let missingFilesTracker = {}; // Track files that are missing from progress data
        let backendCheckInterval = null; // Track backend connectivity
        let wakeLock = null; // Prevent screen sleep during transcription

        // Check backend connectivity on page load
        checkBackendConnectivity();
        
        // Check testing mode status on page load
        checkTestingMode();
        
        // Set up periodic backend connectivity checks
        backendCheckInterval = setInterval(checkBackendConnectivity, 5000); // Check every 5 seconds
        
        // Handle page visibility changes to manage wake lock
        document.addEventListener('visibilitychange', async () => {
            if (document.hidden) {
                // Page is hidden, release wake lock
                await releaseWakeLock();
            } else if (selectedFiles.some(f => f.status === 'transcribing')) {
                // Page is visible again and transcription is still in progress, request wake lock
                await requestWakeLock();
            }
        });
        
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            uploadFiles(files);
        });

        async function uploadFiles(files) {
            const formData = new FormData();
            files.forEach(file => {
                formData.append('files', file);
            });

            try {
                const response = await fetch(`${API_BASE_URL}/upload`, {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (response.ok) {
                    // Add uploaded files to selectedFiles array
                    result.files.forEach(fileInfo => {
                        const isTranscript = fileInfo.filename.toLowerCase().endsWith('.srt');
                        selectedFiles.push({
                            id: fileInfo.id,
                            filename: fileInfo.filename,
                            size: fileInfo.size, // Add file size
                            status: isTranscript ? 'completed' : 'pending', // Transcript files are already completed
                            error: null,
                            transcript: null,
                            isTranscript: isTranscript, // Track if this is a transcript file
                            // Initialize previous values to prevent unnecessary updates
                            previousStatus: isTranscript ? 'completed' : 'pending',
                            previousError: null
                        });
                    });
                    
                    renderFiles();
                    updateTranscribeButton();
                } else {
                    showError(`Upload failed: ${result.error}`);
                }
            } catch (error) {
                showError(`Upload failed: ${error.message}`);
            }
        }

        function renderFiles() {
            const container = document.getElementById('filesContainer');
            
            if (selectedFiles.length === 0) {
                container.classList.remove('has-files');
                return;
            }

            container.classList.add('has-files');
            container.innerHTML = selectedFiles.map(fileData => {
                const isVideo = fileData.filename.toLowerCase().match(/\.(mp4|mpeg|mpga|webm|m4v)$/);
                const isTranscript = fileData.isTranscript;
                
                return `
                    <div class="file-item" data-id="${fileData.id}">
                        <div class="file-preview">
                            ${isTranscript ? 
                                `<svg class="audio-icon" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                                </svg>` :
                                isVideo ? 
                                `<svg class="audio-icon" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M8,5.14V19.14L19,12.14L8,5.14Z" />
                                </svg>` :
                                `<svg class="audio-icon" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M12,3V13.55C11.41,13.21 10.73,13 10,13A3,3 0 0,0 7,16A3,3 0 0,0 10,19A3,3 0 0,0 13,16V7H18V5H12V3Z" />
                                </svg>`
                            }
                            <span class="file-size">${formatBytes(fileData.size)}</span>
                        </div>
                        <div class="file-info">
                            <div class="file-name">${fileData.filename}</div>
                            <div class="file-status">${getStatusText(fileData)}</div>
                            ${fileData.error ? `<div class="error-message">${fileData.error}</div>` : ''}
                            ${fileData.status === 'transcribing' ? 
                                `<div class="progress-bar">
                                    <div class="progress-fill" style="width: ${Math.round(calculateFileProgress(fileData))}%"></div>
                                </div>` : ''
                            }
                            <button class="download-button ${fileData.status === 'completed' ? 'show' : ''}" 
                                    onclick="downloadTranscript('${fileData.id}')">
                                Download Transcript
                            </button>
                        </div>
                        <button class="remove-button" onclick="removeFile('${fileData.id}')">×</button>
                    </div>
                `;
            }).join('');
        }

        function updateFileProgress(fileId, newProgress, newStatus, newError) {
            const fileItem = document.querySelector(`[data-id="${fileId}"]`);
            if (!fileItem) return;
            
            // Update progress bar if it exists
            const progressFill = fileItem.querySelector('.progress-fill');
            if (progressFill && newStatus === 'transcribing') {
                progressFill.style.width = `${Math.round(newProgress)}%`;
            }
            
            // Update status text
            const statusElement = fileItem.querySelector('.file-status');
            if (statusElement) {
                statusElement.textContent = getStatusText({ status: newStatus });
            }
            
            // Update error message
            const errorElement = fileItem.querySelector('.error-message');
            if (newError) {
                if (errorElement) {
                    errorElement.textContent = newError;
                } else {
                    // Create error element if it doesn't exist
                    const fileInfo = fileItem.querySelector('.file-info');
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error-message';
                    errorDiv.textContent = newError;
                    fileInfo.appendChild(errorDiv);
                }
            } else if (errorElement) {
                errorElement.remove();
            }
            
            // Update download button visibility
            const downloadButton = fileItem.querySelector('.download-button');
            if (downloadButton) {
                if (newStatus === 'completed') {
                    downloadButton.classList.add('show');
                } else {
                    downloadButton.classList.remove('show');
                }
            }
            
            // Show/hide progress bar
            const progressBar = fileItem.querySelector('.progress-bar');
            if (newStatus === 'transcribing' || newStatus === 'chunking') {
                if (!progressBar) {
                    const fileInfo = fileItem.querySelector('.file-info');
                    const progressDiv = document.createElement('div');
                    progressDiv.className = 'progress-bar';
                    progressDiv.innerHTML = `<div class="progress-fill" style="width: ${Math.round(newProgress)}%"></div>`;
                    fileInfo.appendChild(progressDiv);
                } else {
                    // Update existing progress bar
                    const progressFill = progressBar.querySelector('.progress-fill');
                    if (progressFill) {
                        progressFill.style.width = `${Math.round(newProgress)}%`;
                    }
                }
            } else if (progressBar) {
                progressBar.remove();
            }
        }

        function getStatusText(fileData) {
            // Check if this is a transcript file
            if (fileData.isTranscript) {
                return 'Transcript file - ready for revision';
            }
            
            switch(fileData.status) {
                case 'pending': return 'Ready to transcribe';
                case 'chunking': return `Processing file (${Math.round(fileData.progress || 0)}% complete)...`;
                case 'transcribing': return 'Transcribing (this may take a while)...';
                case 'completed': return 'Transcription complete';
                case 'error': return 'Transcription failed';
                default: return 'Unknown status';
            }
        }

        async function removeFile(id) {
            try {
                // Call backend to remove file and stop transcription
                const response = await fetch(`${API_BASE_URL}/remove-file/${id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    // Remove from local tracking
                    selectedFiles = selectedFiles.filter(f => f.id != id);
                    delete transcriptionResults[id];
                    delete missingFilesTracker[id];
                    
                    // Stop smooth progress for this file
                    // stopSmoothProgress(id); // Removed smooth progress
                    
                    // Update UI
                    renderFiles();
                    updateTranscribeButton();
                    updateTranscriptDisplay();
                    
                    // If no files left, stop progress monitoring
                    if (selectedFiles.length === 0 && progressInterval) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                        
                        // Release wake lock when all files are removed
                        await releaseWakeLock();
                        
                        // Reset transcribe button
                        const transcribeButton = document.getElementById('transcribeButton');
                        transcribeButton.disabled = false;
                        transcribeButton.textContent = 'Transcribe';
                        transcribeButton.style.opacity = '1';
                    }
                } else {
                    const error = await response.json();
                    showError(`Failed to remove file: ${error.error}`);
                }
            } catch (error) {
                showError(`Failed to remove file: ${error.message}`);
            }
        }

        function updateTranscribeButton() {
            const button = document.getElementById('transcribeButton');
            const hasAudioFiles = selectedFiles.some(f => !f.isTranscript);
            const hasTranscriptFiles = selectedFiles.some(f => f.isTranscript);
            
            // Enable button if there are files to process (either audio files or transcript files)
            button.disabled = selectedFiles.length === 0;
            
            // Update button text based on file types
            if (hasTranscriptFiles && !hasAudioFiles) {
                button.textContent = 'Process Transcripts';
            } else if (hasAudioFiles) {
                button.textContent = 'Transcribe';
            } else {
                button.textContent = 'Transcribe';
            }
        }

        async function startTranscription() {
            const pendingFiles = selectedFiles.filter(f => f.status === 'pending' && !f.isTranscript);
            const chunkingFiles = selectedFiles.filter(f => f.status === 'chunking');
            const transcriptFiles = selectedFiles.filter(f => f.isTranscript);
            
            // If we only have transcript files, skip transcription and go directly to quality control
            if (transcriptFiles.length > 0 && pendingFiles.length === 0 && chunkingFiles.length === 0) {
                console.log('Only transcript files present, skipping transcription');
                
                // Update button text
                const transcribeButton = document.getElementById('transcribeButton');
                transcribeButton.disabled = true;
                transcribeButton.textContent = 'Processing...';
                transcribeButton.style.opacity = '0.6';
                
                // Simulate processing time for transcript files
                setTimeout(() => {
                    transcribeButton.disabled = false;
                    transcribeButton.textContent = 'Process Transcripts';
                    transcribeButton.style.opacity = '1';
                    
                    // Check if quality control should be triggered
                    checkQualityControlStatus();
                }, 2000);
                
                return;
            }
            
            if (pendingFiles.length === 0 && chunkingFiles.length === 0) {
                showError('No files ready for transcription');
                return;
            }
            
            if (chunkingFiles.length > 0) {
                showError(`Some files are still being processed (${chunkingFiles.length} files chunking). Please wait for them to complete.`);
                return;
            }

            // Request wake lock to prevent sleep during transcription
            await requestWakeLock();

            // IMMEDIATELY update UI to show transcription is starting
            pendingFiles.forEach(file => {
                file.status = 'transcribing';
                file.transcriptionStartTime = Date.now();
            });
            
            // Update the display immediately
            renderFiles();
            
            // Disable the transcribe button and change text
            const transcribeButton = document.getElementById('transcribeButton');
            transcribeButton.disabled = true;
            transcribeButton.textContent = 'Transcribing...';
            transcribeButton.style.opacity = '0.6'; // Make it look disabled

            try {
                console.log('Starting transcription for files:', pendingFiles.map(f => f.id));
                
                const response = await fetch(`${API_BASE_URL}/transcribe`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        file_ids: pendingFiles.map(f => f.id)
                    })
                });

                const result = await response.json();
                
                if (response.ok) {
                    console.log('Transcription started successfully:', result);
                    // Start progress monitoring
                    startProgressMonitoring();
                } else {
                    console.error('Transcription failed:', result.error);
                    showError(`Transcription failed: ${result.error}`);
                    
                    // Reset UI on error
                    pendingFiles.forEach(file => {
                        file.status = 'pending';
                        file.progress = 0;
                    });
                    renderFiles();
                    
                    // Re-enable button
                    transcribeButton.disabled = false;
                    transcribeButton.textContent = 'Transcribe';
                    transcribeButton.style.opacity = '1';
                }
            } catch (error) {
                console.error('Transcription request failed:', error);
                showError(`Transcription failed: ${error.message}`);
                
                // Reset UI on error
                pendingFiles.forEach(file => {
                    file.status = 'pending';
                    file.progress = 0;
                });
                renderFiles();
                
                // Re-enable button
                transcribeButton.disabled = false;
                transcribeButton.textContent = 'Transcribe';
                transcribeButton.style.opacity = '1';
            }
        }

        function startProgressMonitoring() {
            if (progressInterval) {
                clearInterval(progressInterval);
            }
            
            progressInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/progress`);
                    const progressData = await response.json();
                    
                    let hasUpdates = false;
                    let filesRemoved = false;
                    
                    // Check if any files were removed from the server
                    selectedFiles.forEach((fileData, index) => {
                        // Skip progress updates for transcript files
                        if (fileData.isTranscript) {
                            return;
                        }
                        
                        console.log(`Checking file ${fileData.id}: status=${fileData.status}, progress=${fileData.progress}`);
                        
                        if (!progressData[fileData.id]) {
                            // File might be temporarily missing during chunking, track it
                            if (!missingFilesTracker[fileData.id]) {
                                missingFilesTracker[fileData.id] = Date.now();
                            }
                            
                            // Only remove if it's been missing for more than 10 seconds
                            const missingTime = Date.now() - missingFilesTracker[fileData.id];
                            if (missingTime > 10000) {
                                console.log(`File ${fileData.id} has been missing for ${missingTime}ms, removing`);
                                selectedFiles.splice(index, 1);
                                delete missingFilesTracker[fileData.id];
                                filesRemoved = true;
                            } else {
                                console.log(`File ${fileData.id} not found in progress data, might be chunking (${missingTime}ms)`);
                            }
                        } else {
                            // File found, remove from missing tracker
                            delete missingFilesTracker[fileData.id];
                            
                            const serverData = progressData[fileData.id];
                            console.log(`Server data for ${fileData.id}: status=${serverData.status}, progress=${serverData.progress}`);
                            
                            if (fileData.status !== serverData.status || 
                                fileData.error !== serverData.error ||
                                fileData.progress !== serverData.progress) {
                                
                                console.log(`Updating file ${fileData.id}: status ${fileData.status} -> ${serverData.status}, progress ${fileData.progress} -> ${serverData.progress}`);
                                fileData.status = serverData.status;
                                fileData.error = serverData.error;
                                fileData.progress = serverData.progress;
                                fileData.transcript = serverData.transcript;
                                
                                // For chunked files, track chunks and calculate progress
                                if (fileData.is_original && serverData.status === 'transcribing') {
                                    // Initialize chunks tracking if not already done
                                    if (!fileData.chunks) {
                                        fileData.chunks = [];
                                        fileData.transcriptionStartTime = Date.now();
                                        
                                        // Find all chunks for this original file
                                        Object.keys(progressData).forEach(chunkId => {
                                            const chunkData = progressData[chunkId];
                                            if (chunkData.original_file === fileData.filename) {
                                                fileData.chunks.push(chunkId);
                                            }
                                        });
                                    }
                                    
                                    // Update chunk statuses
                                    fileData.chunks.forEach(chunkId => {
                                        if (progressData[chunkId]) {
                                            const chunkData = progressData[chunkId];
                                            let chunkFile = selectedFiles.find(f => f.id === chunkId);
                                            if (!chunkFile) {
                                                // Add chunk file to tracking
                                                selectedFiles.push({
                                                    id: chunkId,
                                                    filename: chunkData.original_filename || chunkId,
                                                    status: chunkData.status,
                                                    error: chunkData.error,
                                                    transcript: chunkData.transcript,
                                                    is_chunk: true,
                                                    original_file: fileData.id
                                                });
                                            } else {
                                                chunkFile.status = chunkData.status;
                                                chunkFile.error = chunkData.error;
                                                chunkFile.transcript = chunkData.transcript;
                                            }
                                        }
                                    });
                                }
                                
                                hasUpdates = true;
                            }
                        }
                    });
                    
                    if (hasUpdates || filesRemoved) {
                        // Use targeted updates instead of re-rendering everything
                        if (hasUpdates) {
                            // Update only the files that changed
                            selectedFiles.forEach(fileData => {
                                if (fileData.status !== fileData.previousStatus || 
                                    fileData.error !== fileData.previousError) {
                                    
                                    updateFileProgress(fileData.id, calculateFileProgress(fileData), fileData.status, fileData.error);
                                    
                                    // Store current values as previous for next comparison
                                    fileData.previousStatus = fileData.status;
                                    fileData.previousError = fileData.error;
                                }
                            });
                        }
                        
                        if (filesRemoved) {
                            // Only re-render if files were removed (this is rare)
                            renderFiles();
                        }
                        
                        updateTranscriptDisplay();
                        updateTranscribeButton();
                        checkAllComplete();
                    }
                    
                    // Stop monitoring if all files are complete, have errors, or no files left
                    // For chunked files, we need to check if ALL chunks are complete, not just the original file
                    const allFinished = selectedFiles.length === 0 || selectedFiles.every(f => {
                        // If this is a transcript file, consider it finished
                        if (f.isTranscript) {
                            return true;
                        }
                        // If this is a chunked file, check if all chunks are complete
                        if (f.is_original) {
                            // For original files, we need to check if all chunks are done
                            // This will be handled by the backend progress updates
                            return f.status === 'completed' || f.status === 'error';
                        } else {
                            // For single files, check if they're complete
                            return f.status === 'completed' || f.status === 'error';
                        }
                    });
                    
                    if (allFinished) {
                        clearInterval(progressInterval);
                        progressInterval = null;
                        
                        // Release wake lock when transcription is complete
                        await releaseWakeLock();
                        
                        // Reset transcribe button when all files are finished
                        const transcribeButton = document.getElementById('transcribeButton');
                        transcribeButton.disabled = false;
                        transcribeButton.textContent = 'Transcribe';
                        transcribeButton.style.opacity = '1';
                        
                        // Clear all file previews when transcription is complete
                        selectedFiles = [];
                        renderFiles();
                        
                        // Clean up input files
                        try {
                            await fetch(`${API_BASE_URL}/cleanup`, { method: 'POST' });
                        } catch (error) {
                            console.error('Cleanup failed:', error);
                        }
                    }
                    
                } catch (error) {
                    console.error('Progress monitoring failed:', error);
                }
            }, 1000); // Check every second
        }

        function updateTranscriptDisplay() {
            const transcriptContainer = document.getElementById('transcriptContainer');
            
            // Get currently completed files
            const completedFiles = selectedFiles.filter(f => f.status === 'completed' || f.status === 'error');
            
            if (completedFiles.length > 0) {
                // Show container if it's hidden
                transcriptContainer.classList.add('show');
                
                // Add new transcript items without re-rendering existing ones
                completedFiles.forEach(fileData => {
                    // Check if this transcript item already exists
                    const existingItem = transcriptContainer.querySelector(`[data-transcript-id="${fileData.id}"]`);
                    if (!existingItem) {
                        // Create new transcript item
                        const transcriptDiv = document.createElement('div');
                        transcriptDiv.className = 'transcript-item';
                        transcriptDiv.setAttribute('data-transcript-id', fileData.id);
                        
                        // Determine what to display in the text field
                        let displayText = '';
                        let fieldClass = 'transcript-field';
                        
                        if (fileData.status === 'completed' && fileData.transcript) {
                            displayText = fileData.transcript;
                        } else if (fileData.status === 'error' && fileData.error) {
                            displayText = `Error: ${fileData.error}`;
                            fieldClass += ' error-field'; // Add error styling
                        } else if (fileData.status === 'completed') {
                            displayText = 'Transcription completed but no transcript available.';
                        } else {
                            displayText = 'No transcript or error information available.';
                        }
                        
                        transcriptDiv.innerHTML = `
                            <div class="transcript-title">${fileData.filename}</div>
                            <textarea class="${fieldClass}" readonly>${displayText}</textarea>
                        `;
                        transcriptContainer.appendChild(transcriptDiv);
                    }
                });
            } else {
                transcriptContainer.classList.remove('show');
            }
        }

        function checkAllComplete() {
            const allComplete = selectedFiles.length > 0 && 
                               selectedFiles.every(f => f.status === 'completed' || f.status === 'error' || f.isTranscript);
            
            if (allComplete && (selectedFiles.some(f => f.status === 'completed') || selectedFiles.some(f => f.isTranscript))) {
                // Collect errors from files that failed
                const errorFiles = selectedFiles.filter(f => f.status === 'error' && f.error);
                const errorSummary = document.getElementById('errorSummary');
                
                if (errorFiles.length > 0) {
                    // Display errors
                    const errorText = errorFiles.map(f => `${f.filename}: ${f.error}`).join('\n');
                    errorSummary.textContent = `Errors occurred:\n${errorText}`;
                    errorSummary.style.display = 'block';
                } else {
                    // No errors, hide error summary
                    errorSummary.style.display = 'none';
                }
                
                document.getElementById('successSection').classList.add('show');
                
                // Auto-scroll to the download button
                setTimeout(() => {
                    document.getElementById('successSection').scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                }, 500);
            }
        }

        async function downloadTranscript(id) {
            try {
                const response = await fetch(`${API_BASE_URL}/download/${id}`);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = response.headers.get('content-disposition')?.split('filename=')[1] || 'transcript.srt';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } else {
                    const error = await response.json();
                    showError(`Download failed: ${error.error}`);
                }
            } catch (error) {
                showError(`Download failed: ${error.message}`);
            }
        }

        async function downloadAllTranscripts() {
            try {
                const response = await fetch(`${API_BASE_URL}/download-all`);
                
                if (response.ok) {
                    const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                    a.download = 'all_transcripts.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                } else {
                    const error = await response.json();
                    showError(`Download failed: ${error.error}`);
                }
            } catch (error) {
                showError(`Download failed: ${error.message}`);
            }
        }

        function showError(message) {
            // Create a temporary error message
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #dc3545;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 1000;
                max-width: 300px;
                word-wrap: break-word;
            `;
            errorDiv.textContent = message;
            
            document.body.appendChild(errorDiv);
            
            // Remove after 5 seconds
            setTimeout(() => {
                if (errorDiv.parentNode) {
                    errorDiv.parentNode.removeChild(errorDiv);
                }
            }, 5000);
        }

        let qualityControlFiles = [];
        let qualityControlProgress = {};
        let qualityControlResults = {};

        async function checkQualityControlStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/quality-control/status`);
                const data = await response.json();
                
                if (data.all_transcriptions_complete && data.transcript_files_count > 0) {
                    // Show quality control section
                    const qcSection = document.getElementById('qualityControlSection');
                    qcSection.style.display = 'block';
                    
                    // Update section with current status
                    updateQualityControlSectionStatus(data);
                    
                    // Load files for revision
                    await loadQualityControlFiles();
                } else {
                    // Hide quality control section
                    document.getElementById('qualityControlSection').style.display = 'none';
                }
            } catch (error) {
                console.log('Failed to check quality control status:', error);
                // Don't show error to user for background checks
            }
        }

        function updateQualityControlSectionStatus(data) {
            const subtitle = document.querySelector('#qualityControlSection .section-subtitle');
            const statusElement = document.getElementById('qualityControlStatus');
            
            if (data.quality_control_completed) {
                subtitle.textContent = 'Quality control completed! Download revised transcripts below.';
                subtitle.style.color = '#28a745';
                statusElement.style.display = 'block';
                statusElement.className = 'quality-control-status completed';
                statusElement.textContent = '✅ Quality Control Complete - Revised transcripts are ready for download';
            } else if (data.all_transcriptions_complete) {
                subtitle.textContent = `Ready to revise ${data.transcript_files_count} transcript file${data.transcript_files_count > 1 ? 's' : ''} using ChatGPT`;
                subtitle.style.color = '#666';
                statusElement.style.display = 'block';
                statusElement.className = 'quality-control-status ready';
                statusElement.textContent = `📝 Ready to revise ${data.transcript_files_count} transcript file${data.transcript_files_count > 1 ? 's' : ''}`;
            } else {
                subtitle.textContent = 'Waiting for all transcriptions to complete...';
                subtitle.style.color = '#ffc107';
                statusElement.style.display = 'block';
                statusElement.className = 'quality-control-status waiting';
                statusElement.textContent = '⏳ Waiting for all transcriptions to complete...';
            }
        }

        async function loadQualityControlFiles() {
            try {
                const response = await fetch(`${API_BASE_URL}/quality-control/status`);
                const data = await response.json();
                
                qualityControlFiles = data.transcript_files || [];
                
                renderQualityControlFiles();
                updateReviseButton();
                
                // If quality control is already completed, show results
                if (data.quality_control_completed) {
                    await loadQualityControlResults();
                    showRevisionComplete();
                }
            } catch (error) {
                console.log('Failed to load quality control files:', error);
                showError('Failed to load quality control files');
            }
        }

        function renderQualityControlFiles() {
            const container = document.getElementById('reviseFilesContainer');
            
            if (qualityControlFiles.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">No files ready for revision</p>';
                container.classList.remove('has-files');
                return;
            }
            
            container.classList.add('has-files');
            container.innerHTML = qualityControlFiles.map(filename => `
                <div class="revise-file-item">
                    <div class="revise-file-preview">
                        <svg class="audio-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12,3V13.55C11.41,13.21 10.73,13 10,13A3,3 0 0,0 7,16A3,3 0 0,0 10,19A3,3 0 0,0 13,16V7H18V5H12V3Z" />
                        </svg>
                        <div class="revise-file-info">
                            <div class="revise-file-name">${filename}</div>
                            <div class="revise-file-size">Ready for revision</div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function updateReviseButton() {
            const button = document.getElementById('reviseButton');
            const hasFiles = qualityControlFiles.length > 0;
            
            button.disabled = !hasFiles;
            
            if (hasFiles) {
                button.innerHTML = `
                    <svg class="revise-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z" />
                    </svg>
                    Revise ${qualityControlFiles.length} Transcript${qualityControlFiles.length > 1 ? 's' : ''}
                `;
            } else {
                button.innerHTML = `
                    <svg class="revise-icon" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z" />
                    </svg>
                    Revise Transcripts
                `;
            }
        }

        async function startQualityControl() {
            const button = document.getElementById('reviseButton');
            
            try {
                // Disable button and show loading state
                button.disabled = true;
                button.innerHTML = `
                    <div class="loading-spinner"></div>
                    Processing with ChatGPT...
                `;
                
                // Show progress container
                document.getElementById('reviseProgressContainer').style.display = 'block';
                renderQualityControlProgress();
                
                // Start quality control
                const response = await fetch(`${API_BASE_URL}/quality-control/trigger`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    // Monitor progress with real-time updates
                    await monitorQualityControlProgressRealTime();
                    
                    // Show results
                    await loadQualityControlResults();
                    showRevisionComplete();
                } else {
                    const errorMessage = result.error || result.message || 'Unknown error occurred';
                    showError(`Quality control failed: ${errorMessage}`);
                    resetQualityControlUI();
                }
                
            } catch (error) {
                console.error('Quality control error:', error);
                showError(`Quality control failed: ${error.message}`);
                resetQualityControlUI();
            }
        }

        function renderQualityControlProgress() {
            const container = document.getElementById('reviseProgressContainer');
            
            container.innerHTML = qualityControlFiles.map(filename => `
                <div class="file-item" data-qc-file="${filename}">
                    <div class="file-preview">
                        <svg class="audio-icon" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12,3V13.55C11.41,13.21 10.73,13 10,13A3,3 0 0,0 7,16A3,3 0 0,0 10,19A3,3 0 0,0 13,16V7H18V5H12V3Z" />
                        </svg>
                        <span class="file-size">Processing...</span>
                    </div>
                    <div class="file-info">
                        <div class="file-name">${filename}</div>
                        <div class="file-status">Revising with ChatGPT...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        async function monitorQualityControlProgressRealTime() {
            // Real-time progress monitoring with status updates
            const maxDuration = 300000; // 5 minutes max
            const startTime = Date.now();
            let currentProgress = 0;
            
            const updateProgress = (progress, status) => {
                const progressBars = document.querySelectorAll('#reviseProgressContainer .progress-fill');
                const statusElements = document.querySelectorAll('#reviseProgressContainer .file-status');
                
                progressBars.forEach(bar => {
                    bar.style.width = `${progress}%`;
                });
                
                statusElements.forEach(statusEl => {
                    statusEl.textContent = status;
                });
            };
            
            // Initial status
            updateProgress(0, 'Initializing quality control...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Simulate realistic progress stages
            const stages = [
                { progress: 10, status: 'Analyzing transcripts...', delay: 2000 },
                { progress: 25, status: 'Identifying errors...', delay: 3000 },
                { progress: 40, status: 'Generating corrections...', delay: 4000 },
                { progress: 60, status: 'Applying revisions...', delay: 3000 },
                { progress: 80, status: 'Finalizing corrections...', delay: 2000 },
                { progress: 95, status: 'Saving revised transcripts...', delay: 1000 },
                { progress: 100, status: 'Quality control complete!', delay: 500 }
            ];
            
            for (const stage of stages) {
                updateProgress(stage.progress, stage.status);
                await new Promise(resolve => setTimeout(resolve, stage.delay));
                
                // Check if we've exceeded max duration
                if (Date.now() - startTime > maxDuration) {
                    updateProgress(100, 'Quality control completed (timeout)');
                    break;
                }
            }
        }

        async function loadQualityControlResults() {
            try {
                // Check if revised transcripts are available
                const response = await fetch(`${API_BASE_URL}/quality-control/status`);
                const statusData = await response.json();
                
                if (statusData.quality_control_completed) {
                    // Load actual revised transcripts
                    const downloadResponse = await fetch(`${API_BASE_URL}/download-all-revised`);
                    if (downloadResponse.ok) {
                        // For now, we'll show a success message since we can't easily parse the zip
                        qualityControlResults = {};
                        for (const filename of qualityControlFiles) {
                            qualityControlResults[filename] = `✅ Revised transcript for ${filename} has been processed and saved.\n\nQuality control has been completed successfully. The revised transcript contains corrected errors and improved accuracy for training the language model.\n\nYou can download all revised transcripts using the button below.`;
                        }
                    } else {
                        throw new Error('Failed to download revised transcripts');
                    }
                } else {
                    // Fallback to simulated results
                    qualityControlResults = {};
                    for (const filename of qualityControlFiles) {
                        qualityControlResults[filename] = `✅ Revised transcript for ${filename} has been processed.\n\nQuality control has been completed successfully. The revised transcript contains corrected errors and improved accuracy for training the language model.\n\nNote: This is a simulation. In production, actual revised transcripts would be available for download.`;
                    }
                }
                
                renderQualityControlResults();
            } catch (error) {
                console.log('Failed to load quality control results:', error);
                // Show error in results
                qualityControlResults = {};
                for (const filename of qualityControlFiles) {
                    qualityControlResults[filename] = `❌ Error loading revised transcript for ${filename}: ${error.message}\n\nPlease try downloading the revised transcripts manually or contact support if the issue persists.`;
                }
                renderQualityControlResults();
            }
        }

        function renderQualityControlResults() {
            const container = document.getElementById('reviseResultsContainer');
            
            container.innerHTML = Object.entries(qualityControlResults).map(([filename, content]) => `
                <div class="revise-result-item">
                    <div class="revise-result-title">${filename}</div>
                    <textarea class="revise-result-field" readonly>${content}</textarea>
                </div>
            `).join('');
            
            container.style.display = 'block';
        }

        function showRevisionComplete() {
            document.getElementById('revisionCompleteSection').style.display = 'block';
            
            // Auto-scroll to the completion section
            setTimeout(() => {
                document.getElementById('revisionCompleteSection').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }, 500);
        }

        function resetQualityControlUI() {
            const button = document.getElementById('reviseButton');
            button.disabled = false;
            button.innerHTML = `
                <svg class="revise-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z" />
                </svg>
                Revise Transcripts
            `;
            
            document.getElementById('reviseProgressContainer').style.display = 'none';
            
            // Re-enable the button with updated text
            updateReviseButton();
        }

        async function downloadAllRevisedTranscripts() {
            try {
                const button = document.querySelector('.download-all-revised-button');
                const originalText = button.innerHTML;
                
                // Show loading state
                button.innerHTML = `
                    <div class="loading-spinner"></div>
                    Downloading...
                `;
                button.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/download-all-revised`);
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'all_revised_transcripts.zip';
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    // Show success message
                    showSuccess('Revised transcripts downloaded successfully!');
                } else {
                    const error = await response.json();
                    showError(`Download failed: ${error.error || 'Unknown error'}`);
                }
            } catch (error) {
                showError(`Download failed: ${error.message}`);
            } finally {
                // Restore button state
                const button = document.querySelector('.download-all-revised-button');
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }

        function showSuccess(message) {
            // Create a temporary success message
            const successDiv = document.createElement('div');
            successDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 1000;
                max-width: 300px;
                word-wrap: break-word;
            `;
            successDiv.textContent = message;
            
            document.body.appendChild(successDiv);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (successDiv.parentNode) {
                    successDiv.parentNode.removeChild(successDiv);
                }
            }, 3000);
        }

        // Check quality control status periodically
        setInterval(checkQualityControlStatus, 5000);

        async function checkBackendConnectivity() {
            try {
                const response = await fetch(`${API_BASE_URL}/progress`, {
                    method: 'GET',
                    // Add a timeout to prevent long waits
                    signal: AbortSignal.timeout(3000) // 3 second timeout
                });
                
                if (response.ok) {
                    // Backend is running, hide error message
                    const errorElement = document.getElementById('backendError');
                    errorElement.classList.remove('show');
                } else {
                    // Backend responded but with error, show error message
                    const errorElement = document.getElementById('backendError');
                    errorElement.classList.add('show');
                }
            } catch (error) {
                // Backend is not running or unreachable, show error message
                const errorElement = document.getElementById('backendError');
                errorElement.classList.add('show');
                console.log('Backend connectivity check failed:', error.message);
            }
        }

        async function checkTestingMode() {
            try {
                const response = await fetch(`${API_BASE_URL}/testing-mode`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(3000) // 3 second timeout
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const bannerElement = document.getElementById('testingModeBanner');
                    
                    if (data.testing_mode) {
                        // Testing mode is ON - show green banner
                        bannerElement.textContent = '🧪 Testing Mode: Whisper API is disabled for free development testing';
                        bannerElement.className = 'testing-mode-banner testing show';
                    } else {
                        // Testing mode is OFF - show yellow banner
                        bannerElement.textContent = '⚠️ Production Mode: Whisper API is enabled - transcription will cost money';
                        bannerElement.className = 'testing-mode-banner production show';
                    }
                } else {
                    // Hide banner if can't determine testing mode
                    const bannerElement = document.getElementById('testingModeBanner');
                    bannerElement.classList.remove('show');
                }
            } catch (error) {
                // Hide banner if backend is not available
                const bannerElement = document.getElementById('testingModeBanner');
                bannerElement.classList.remove('show');
                console.log('Testing mode check failed:', error.message);
            }
        }

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock requested successfully');
                    
                    // Listen for wake lock release
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake lock was released');
                    });
                } else {
                    console.log('Wake Lock API not supported in this browser');
                }
            } catch (err) {
                console.log('Failed to request wake lock:', err);
            }
        }

        async function releaseWakeLock() {
            try {
                if (wakeLock) {
                    await wakeLock.release();
                    wakeLock = null;
                    console.log('Wake lock released successfully');
                }
            } catch (err) {
                console.log('Failed to release wake lock:', err);
            }
        }

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        function calculateFileProgress(fileData) {
            // Use server-provided progress if available
            if (fileData.progress !== undefined) {
                return fileData.progress;
            }
            
            // Fallback to calculated progress for backward compatibility
            // For single files (not chunked), progress is 0% when transcribing, 100% when completed
            if (!fileData.is_original) {
                return fileData.status === 'completed' ? 100 : 0;
            }
            
            // For chunked files, calculate progress based on completed chunks
            if (!fileData.chunks || fileData.chunks.length === 0) {
                return 0;
            }
            
            const completedChunks = fileData.chunks.filter(chunkId => {
                const chunkData = selectedFiles.find(f => f.id === chunkId);
                return chunkData && chunkData.status === 'completed';
            }).length;
            
            const totalChunks = fileData.chunks.length;
            const baseProgress = (completedChunks / totalChunks) * 100;
            
            // If all chunks are completed, return 100%
            if (completedChunks === totalChunks) {
                return 100;
            }
            
            // If file is still transcribing, add smooth animation
            if (fileData.status === 'transcribing') {
                const elapsed = (Date.now() - fileData.transcriptionStartTime) / 1000;
                const chunkProgress = (1 / totalChunks) * 100;
                const animationProgress = Math.min(
                    chunkProgress - 1, // 1% less than next checkpoint
                    chunkProgress * (-Math.pow(10, -0.1 * elapsed) + 1)
                );
                
                return baseProgress + animationProgress;
            }
            
            return baseProgress;
        }
    </script>
</body>
</html>